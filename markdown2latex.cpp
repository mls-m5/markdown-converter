/*
 * markdown2latex.cpp
 *
 *  Created on: 23 maj 2015
 *      Author: Mattias Larsson Sköld
 */




#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>

using namespace std;


const string documentHeader = R"tag(
%autogenerated latexfile using markdown2latex
\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\begin{document}

)tag";


const string documentEnding = R"tag(

\end{document}

)tag";

string listTag = "";

#include <algorithm>
#include <functional>
#include <cctype>
#include <locale>

// trim from start
static inline std::string &ltrim(std::string &s) {
        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
        return s;
}

// trim from end
static inline std::string &rtrim(std::string &s) {
        s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
        return s;
}

// trim from both ends
static inline std::string &trim(std::string &s) {
        return ltrim(rtrim(s));
}


string beginTag(string tag) {
	return "\\begin{" + trim(tag) + "}\n";
}

string endTag(string tag) {
	return "\\end{" + trim(tag) + "}\n";
}

string encapsulate(string text, string tag) {
	return "\\" + trim(tag) + "{" + text + "}";
}





string tryBeginList(string tag) {
	if (listTag.empty()) {
		listTag = tag;
		return beginTag(tag) + "\n";
	}
	return "";
}

string tryEndList() {
	if (not listTag.empty()){
		auto tag = listTag;
		listTag = "";
		return endTag(tag) + "\n";
	}
	return "";
}

string generateSectionString(int depth) {
	string ret;
	for (int i = 1; i < depth; ++i) {
		ret += "sub";
	}
	return ret + "section";
}


string processLine(string line, string nextLine) {
	auto c = line[0];
	auto nc = nextLine[0];
	string returnString;
	if (c == '=' or c == '-') {
		return "";
	}
	else if (c == '#') {
		int headerLevel = 0;
		auto headerContent = line;
		while (headerContent.front() == '#') {
			headerContent = headerContent.substr(1);
			headerLevel ++;
		}

		while (headerContent.back() == '#' or isspace(headerContent.back())) {
			headerContent.pop_back();
		}

		return encapsulate(headerContent, generateSectionString(headerLevel));
	}
	else if (c == '*') {
		auto listHead = tryBeginList("itemize");
		auto content = line.substr(1);

		return listHead + encapsulate(content, "item");
	}
	else if (isdigit(c) and line.find('.') != string::npos) {
		auto listHead = tryBeginList("enumerate");
		auto f = line.find('.');
		auto content = line.substr(f + 1);

		return listHead + encapsulate(content, "item");
	}
	else {
		returnString += tryEndList();
	}

	if (nc == '=') {
		return returnString + encapsulate(line, "section");
	}
	else if (nc == '-') {
		return returnString + encapsulate(line, "subsection");
	}
	return returnString + line;
}


int main(int argc, char **argv) {
	string filename = "README.md";
	if (argc > 1) {
		filename = argv[1];
	}

	fstream file(filename);

	string line;
	string previousLine;

	if (file.is_open()) {
		cout << documentHeader << endl;
	}
	else {
		cerr << "kunde inte öppna fil: " << filename << endl;
	}

	while (file) {
		getline(file, line);
		cout << processLine(previousLine, line) << endl;



		previousLine = line;
	}

	cout << documentEnding << endl;
}
